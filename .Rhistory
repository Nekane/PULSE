netrev
head(netrev)
dcast(netrev, year ~ value, mean)
library("reshape", lib.loc="~/R/x86_64-pc-linux-gnu-library/3.2")
dcast(netrev, year ~ value, mean)
library("reshape2", lib.loc="~/R/x86_64-pc-linux-gnu-library/3.2")
dcast(netrev, year ~ value, mean)
aggregate(netrev, by=year, mean)
head(netrev)
aggregate(netrev$value, list(netrev$year), mean)
aggregate(netrev$value/1000, list(netrev$year), mean)
boxplot(value/1000~ year, netrev, cex = 0.6, col="grey",boxwex=1, xlab = "Year", ylab = "Mean net revenue", xlim=c(1, NUMRUNS+1), ylim=ylim, xaxt = "n",outline=FALSE, las=1)
ylim <- c(0, 50)
boxplot(value/1000~ year, netrev, cex = 0.6, col="grey",boxwex=1, xlab = "Year", ylab = "Mean net revenue", xlim=c(1, NUMRUNS+1), ylim=ylim, xaxt = "n",outline=FALSE, las=1)
options(width=240)
library(RDynState5NAsigmaseason12Age)
library(ggplot2)
library(reshape2)
library(plyr)
library(scales)
#setwd("~/Nekane_MSE/complex model/")
source("functions.R")
##############################################################################
# POPULATION DYNAMICS
##############################################################################
population_dynamics <- function(pop, startyear, endyear, season, natmortality, catches, recruitment, migration){
#pop[age,year, season, area]
MigToArea <- array(0, dim=dim(migration), dimnames= dimnames(migration))
for (y in (startyear:endyear)){     # need to think this, but maybe is better change last year (y in (endy:(endy +10)))
for (ss in (1:length(season))){
# move time ---------------------
if (ss ==1){
for(age in 2:(dim(pop)[1])){
pop[age,as.character(y),as.character(ss),] <- pop[age-1,as.character(y-1),as.character(length(season)),];
}
} else {
pop[,as.character(y),as.character(ss),] <- pop[,as.character(y),as.character(ss-1),];
}
# birth/recruitment ---------------------
if (ss ==1){
pop[1,as.character(y),as.character(ss),] <- recruitment;
}
# natural mortality  ---------------------
pop[,as.character(y),as.character(ss),] <- pop[,as.character(y),as.character(ss),]*(1-natmortality)
pop[pop < 1e-1 ] <- 1e-1
# remove catches (dims of catches here is ages,season, area, just like in main )
pop[,as.character(y),as.character(ss),] <- pop[,as.character(y),as.character(ss),] - catches[,,as.character(ss),]
pop[pop < 1e-1 ] <- 1e-1
#migration
for (age in (1:dim(pop)[1])){
MigToArea[age,1,as.character(ss),,] <- 0
for (toarea in (dimnames(pop)[4][[1]])){
for (fromarea in (dimnames(pop)[4][[1]])){
MigToArea[age,1,as.character(ss),toarea, fromarea] <-  MigToArea[age,1,as.character(ss),toarea,fromarea] + ( pop[age,as.character(y),as.character(ss),fromarea] * migration[age,1,as.character(ss),fromarea, toarea])
}
}
for (toarea in (dimnames(pop)[4][[1]])){
for (fromarea in (dimnames(pop)[4][[1]])){
pop[age,as.character(y),as.character(ss),toarea]  <-  pop[age,as.character(y),as.character(ss),toarea] +  MigToArea[age,1,as.character(ss),toarea, fromarea]
}
}
}
}
}
return(pop)
}
##############################################################################
# YIELD CURVE
##############################################################################
yield_curve <- function(hr,lratio, wts, natmortality, R=1, sequence = seq(0.001,5,0.005), verbose=F ){
# note that definition of hr is not completely correct (should be sum over seasons, and mean over ages), but as long as consistently incorect in code it should not matter
res <- data.frame("hr"=mean(hr) *sequence,"catch"=NA, "landings"=NA)
iii <- 1
sumR <- sum(R)
if (verbose == T){
print("total Recruitment")
print(R)
}
for (ii in sequence){
respop <- yld <-  matrix(0,nrow=length(ages), ncol=length(season), dimnames=list("cat"=ages,"season"=season))
respop[1,1] <- sumR
for(aa in ages){
if (aa==1){
# respop[aa,1] <- respop[aa,1] * (1-natmortality*1)
respop[aa,1] <- respop[aa,1] * (1-(hr[aa,1]*ii))
yld[aa,1]    <- sumR   - respop[aa,1]
respop[aa,1] <- respop[aa,1] * (1-natmortality*1)
}
if (aa > 1){
respop[aa,1] <- respop[aa-1,max(season)] * (1-natmortality*0)
respop[aa,1] <- respop[aa,1]             * (1-(hr[aa,1] *ii))
yld[aa,1]    <- respop[aa-1,max(season)] - respop[aa,1]
respop[aa,1] <- respop[aa,1]             * (1-natmortality*1)
}
for (ss in 2:(max(season))){
respop[aa,ss] <- respop[aa,ss-1] * (1-natmortality*0)
respop[aa,ss] <- respop[aa,ss]   * (1-(hr[aa,ss]*ii))
yld[aa,ss]    <- respop[aa,ss-1] - respop[aa,ss]
respop[aa,ss] <- respop[aa,ss]   * (1-natmortality*1)
}
}
res[iii, ]$catch    <- sum(yld*wts[,1,,1])
res[iii, ]$landings <- sum(yld*lratio*wts[,1,,1])
iii <- iii + 1
if (verbose == T){
print("yields (in numbers)")
print(yld)
print(" ")
print("population (in numbers)")
print(respop)
}
}
return(res)
}
#SIGMAS        <- c(10, 40, 70, 100)   #SIGMA         <- 100 #comes from 2// chanheg from 300 to 200
#NVESSELS      <- c(600, 700, 800)     #SIMNUMBER     <- 600
#for (pos in NVESSELS){
#  for (sig in SIGMAS){
ages          <- 1:6
season        <- 1:12
areas         <- c("a", "b")
stab.model    <- 10
NUMRUNS       <- 30
MPstart       <- 25
#MPstartLO     <- 26
SIMNUMBER     <- 8000 #pos 8000 WORKS
SIGMA         <- 4000 #5000 #sig 6500 WORKS
SPP1DSCSTEPS  <- 0
SPP2DSCSTEPS  <- 0
endy          <- stab.model + NUMRUNS
Linf          <- 50 #50
K             <- 0.6 #0.4
alpha         <- 0.0002#0.00005
beta          <- 3
sages         <- array(seq(min(ages)+((1/max(season))/2), max(ages+1),1/max(season)), dim=c(length(season),1,length(ages),1), dimnames=list(season=as.character(season),   year="all", cat=ages, option ="all"))
lens          <- Linf*(1-exp(-K*(sages)))
wts           <- alpha * lens ^ beta
wts           <- aperm(wts, c(3,2,1,4))
q             <- 0.000025
natmortality  <- 0.0001
migconstant   <- 0.025 #
sp1price      <- sp2price      <- 30000
slope1price <- 0.50*sp1price
slope2price <- 0.50*sp2price#1000 # 0.50*150
FuelPrice   <- 2000
# scenario I: discarding is not allowed, YPR based in C (C=L)
# scenario II: discarding is allowed, YPR based in L, hr wanted based in catches
# scenario III: discarding ocurred but not perceived, YPR based in L, hr wanted based in landings
recs1          <- c(500,0)
mig1     <- array(0, dim=c(length(ages),1,length(season),length(areas), length(areas)), dimnames=list(cat=ages,year="all",season=as.character(season), from =areas, to=areas))
mig1[,,,"a","a"] <- -migconstant
mig1[,,,"b","b"] <- -migconstant
mig1[,,,"a","b"] <- migconstant
mig1[,,,"b","a"] <- migconstant
aperm( mig1,c(1,3,2,4,5))
recs2          <- c(0,500)
mig2     <- array(0, dim=c(length(ages),1,length(season),length(areas), length(areas)), dimnames=list(cat=ages,year="all",season=as.character(season), from =areas, to=areas))
mig2[,,,"a","a"] <- -migconstant
mig2[,,,"b","b"] <- -migconstant
mig2[,,,"a","b"] <- migconstant
mig2[,,,"b","a"] <- migconstant
aperm( mig2,c(1,3,2,4,5))
effort <- array(c(1), dim=c(length(areas), length(season)), dimnames=list(option =areas,season=as.character(season)))
pop1  <- pop2         <-array(0, dim=c(length(ages),endy+1,length(season),length(areas)), dimnames=list(cat=ages,   year=as.character(1:(endy+1)), season=as.character(season), option =areas))
catches.n.dsvm1       <- catches.n.dsvm2       <- array(0, dim=c(length(ages),endy,length(season),length(areas)), dimnames=list(cat=ages,   year=as.character(1:endy), season=as.character(season), option =areas))
landings.n.dsvm1      <- landings.n.dsvm2      <- array(0, dim=c(length(ages),endy,length(season),length(areas)), dimnames=list(cat=ages,   year=as.character(1:endy), season=as.character(season), option =areas))
catches.wt.dsvm1      <- catches.wt.dsvm2      <- array(0, dim=c(length(ages),endy,length(season),length(areas)), dimnames=list(cat=ages,   year=as.character(1:endy), season=as.character(season), option =areas))
landings.wt.dsvm1     <- landings.wt.dsvm2     <- array(0, dim=c(length(ages),endy,length(season),length(areas)), dimnames=list(cat=ages,   year=as.character(1:endy), season=as.character(season), option =areas))
catches.wt.dsvm.tot1  <- catches.wt.dsvm.tot2  <- array(0, dim=c(1           ,endy,              1,            1), dimnames=list(cat="all", year=as.character(1:endy), season="all",                option ="all"))
landings.wt.dsvm.tot1 <- landings.wt.dsvm.tot2 <- array(0, dim=c(1           ,endy,              1,            1), dimnames=list(cat="all", year=as.character(1:endy), season="all",                option ="all"))
quota1                <- quota2                <- array(1000, dim=c(1           ,endy,              1,            1), dimnames=list(cat="all", year=as.character(1:endy), season="all",                option ="all"))
pos_catches1 <- pos_catches2 <- pop1
hr1wanted <- hr2wanted <- array(NA, dim=c(1           ,endy,              1,            1), dimnames=list(cat="all", year=as.character(1:endy), season="all",                option ="all"))
#run population for 15 year
pop1 <- population_dynamics(pop=pop1, startyear=2, endyear=stab.model, season=season, natmortality=natmortality, catches=catches.n.dsvm1[,1,,, drop=F], recruitment=recs1, migration=mig1)
pop2 <- population_dynamics(pop=pop2, startyear=2, endyear=stab.model, season=season, natmortality=natmortality, catches=catches.n.dsvm1[,1,,, drop=F], recruitment=recs2, migration=mig2)
#set up dsvm
sp1<- sp2 <- sp3 <- sp4 <- sp5 <-    new("DynStateInput")
catchMean(sp1)  <- catchMean(sp2) <- array(NA, dim=c(length(ages), length(season),length(areas)),  dimnames=list("cat"=ages,"season"= season,"option"=areas))
catchMean(sp3)  <- catchMean(sp4) <- catchMean(sp5) <- array(0.01,dim=c(length(ages),length(season),length(areas)),dimnames=list(cat=ages,season=as.character(season),option =areas))
catchSigma(sp3) <- catchSigma(sp4)<- catchSigma(sp5)<- array(0.0000001,dim=c(length(ages),length(season),length(areas)),dimnames=list(cat=ages,season=as.character(season),option =areas))
#SIZE DEPENDENT PRICING, following Zimmermann et al. (2011)
sp1Price <- array(c(sp1price + slope1price*(((wts-mean(wts))/mean(wts)))), dim=c(length(ages),length(season)), dimnames=list(cat=ages,season=as.character(season)))
sp2Price <- array(c(sp2price + slope2price*(((wts-mean(wts))/mean(wts)))), dim=c(length(ages),length(season)), dimnames=list(cat=ages,season=as.character(season)))
sp3Price <- sp4Price <- sp5Price <- array(c(0), dim=c(length(ages),length(season)), dimnames=list(cat=ages,season=as.character(season)))
#---effort and prices used (note that now c is removed (but that if other runs, then make sure to fix/remove code that removes "c" option)
control     <- DynState.control(spp1LndQuota= quota1[,1,,],  spp2LndQuota=quota2[,1,,], spp1LndQuotaFine= 3e6, spp2LndQuotaFine= 3e6, fuelUse = 1, fuelPrice = FuelPrice, landingCosts= 0,gearMaintenance= 0,
addNoFishing= TRUE, increments= 25, spp1DiscardSteps= SPP1DSCSTEPS, spp2DiscardSteps= SPP2DSCSTEPS, sigma= SIGMA, simNumber= SIMNUMBER * 0.5 , numThreads= 68, verbose=1)
quota1
catchMean(sp1)
catchMean(sp1)[1,,] <- pop1[1,as.character(yy-1),,] *q*wts[1,1,,1]
yy<-10
catchMean(sp1)[1,,] <- pop1[1,as.character(yy-1),,] *q*wts[1,1,,1]
catchMean(sp1)
cfracs1 <- sweep( pop1[-1,as.character(yy-1),,] ,c(1,3),  pop1[1:(max(ages)-1),as.character(yy-2),max(season),] , FUN="/")
cfracs2 <- sweep( pop1[-1,as.character(yy-2),,] ,c(1,3),  pop1[1:(max(ages)-1),as.character(yy-3),max(season),] , FUN="/")
cfracs <- (cfracs1 + cfracs2)/2
catchMean(sp1)[-1,,] <- sweep(cfracs,c(1,3),pop1[1:(max(ages)-1),as.character(yy-1),max(season),] ,FUN="*") *q
catchMean(sp1)[-1,,] <- sweep(catchMean(sp1)[-1,,],c(1,2), wts[-1,1,,1],FUN="*")
catchMean(sp2)[1,,] <- pop2[1,as.character(yy-1),,] *q*wts[1,1,,1]
cfracs1 <- sweep( pop2[-1,as.character(yy-1),,] ,c(1,3),  pop2[1:(max(ages)-1),as.character(yy-2),max(season),] , FUN="/")
cfracs2 <- sweep( pop2[-1,as.character(yy-2),,] ,c(1,3),  pop2[1:(max(ages)-1),as.character(yy-3),max(season),] , FUN="/")
cfracs <- (cfracs1 + cfracs2)/2
catchMean(sp2)[-1,,] <- sweep(cfracs,c(1,3),pop2[1:(max(ages)-1),as.character(yy-1),max(season),] ,FUN="*") *q
catchMean(sp2)[-1,,] <- sweep(catchMean(sp2)[-1,,],c(1,2), wts[-1,1,,1],FUN="*")
catchMean(sp1)
sum(catchMean(sp1))
load("~/Dropbox/BoB/MSE/Git/Nekane_MSE/complex model/1quota12seasons.RData")
View(dsvm_res_allyrs)
sum(catchMean(sp1)[,,1])
sum(catchMean(sp1)[,,2])
catchMean(sp1)[,,1]
catchMean(sp1)[,,1]*1919
sum(catchMean(sp1)[,,1]*1919)
sum(catchMean(sp1)[,,2]*2081)
catchMean(sp1)[,,2]*2081
sum(catchMean(sp1)[,,2]*2081)
load("~/Dropbox/BoB/MSE/Git/Nekane_MSE/complex model/1quota12seasons.RData")
quota1
quota1* SIMNUMBER
load("~/Dropbox/BoB/MSE/Git/Nekane_MSE/complex model/1quota12seasons.RData")
ylim=c(0,8000)
xlimYPR <- c(0,0.08)
par(par(no.readonly=TRUE))
par(oma=c(3,3,0,0),mar=c(3,3,2,2),mfrow=c(2,2))
plot(rowMeans(hr1[,pyrnoMP,]), type="b", ylim= xlimYPR,  xlab="Age", ylab = "Selectivity", panel.first=grid(col = "ivory3"), xaxt="n",las=1)
#rect(par("usr")[1], par("usr")[3], par("usr")[2], par("usr")[4], col ="#CCCCCC")
#par(new=TRUE)
text(1,0.078, "Unconstrained", pos=4)
#lines(rowMeans(hr1[,pyrnoMP,]), type="b", ylim= xlimYPR)
lines(rowMeans(hr1[,pyrMP,]), type="b", ylim= xlimYPR, col="#808080")
text(1,max(rowMeans(hr1[,pyrMP,]))+0.01, "Constrained", pos=4)
axis(1, at = seq(1, 6, by = 1))
mtext("(a)", side=3, line = -1.3, adj = 0.96, font=2, cex = 1)
lot(rowMeans(hr2[,pyrnoMP,]), type="b", ylim= xlimYPR,  xlab="Age", ylab = "Selectivity", panel.first=grid(col = "ivory3"), xaxt="n",las=1)
#rect(par("usr")[1], par("usr")[3], par("usr")[2], par("usr")[4], col ="darkseagreen3")
#par(new=TRUE)
text(1,0.078, "Unconstrained", pos=4)
#lines(rowMeans(hr2[,pyrnoMP,]), type="b", ylim= xlimYPR)
lines(rowMeans(hr2[,pyrMP,]), type="b", ylim=  xlimYPR, col="#808080")
text(1,max(rowMeans(hr2[,pyrMP,]))-0.02, "Constrained", pos=4)
axis(1, at = seq(1, 6, by = 1))
mtext("(b)",  side=3, line = -1.3, adj = 0.96, font=2, cex = 1)
ylim=c(0,8000)
xlimYPR <- c(0,0.08)
par(par(no.readonly=TRUE))
par(oma=c(3,3,0,0),mar=c(3,3,2,2),mfrow=c(2,2))
plot(rowMeans(hr1[,pyrnoMP,]), type="b", ylim= xlimYPR,  xlab="Age", ylab = "Selectivity", panel.first=grid(col = "ivory3"), xaxt="n",las=1)
#rect(par("usr")[1], par("usr")[3], par("usr")[2], par("usr")[4], col ="#CCCCCC")
#par(new=TRUE)
text(1,0.078, "Unconstrained", pos=4)
#lines(rowMeans(hr1[,pyrnoMP,]), type="b", ylim= xlimYPR)
lines(rowMeans(hr1[,pyrMP,]), type="b", ylim= xlimYPR, col="#808080")
text(1,max(rowMeans(hr1[,pyrMP,]))+0.01, "Constrained", pos=4)
axis(1, at = seq(1, 6, by = 1))
mtext("(a)", side=3, line = -1.3, adj = 0.96, font=2, cex = 1)
plot(rowMeans(hr2[,pyrnoMP,]), type="b", ylim= xlimYPR,  xlab="Age", ylab = "Selectivity", panel.first=grid(col = "ivory3"), xaxt="n",las=1)
#rect(par("usr")[1], par("usr")[3], par("usr")[2], par("usr")[4], col ="darkseagreen3")
#par(new=TRUE)
text(1,0.078, "Unconstrained", pos=4)
#lines(rowMeans(hr2[,pyrnoMP,]), type="b", ylim= xlimYPR)
lines(rowMeans(hr2[,pyrMP,]), type="b", ylim=  xlimYPR, col="#808080")
text(1,max(rowMeans(hr2[,pyrMP,]))-0.02, "Constrained", pos=4)
axis(1, at = seq(1, 6, by = 1))
mtext("(b)",  side=3, line = -1.3, adj = 0.96, font=2, cex = 1)
plot(rowMeans(hr1[,pyrnoMP,]), type="b", ylim= xlimYPR,  xlab="Age", ylab = "Selectivity", panel.first=grid(col = "ivory3"), xaxt="n",las=1)
text(1,0.078, "Unconstrained", pos=4)
lines(rowMeans(hr1[,38,]), type="b", ylim= xlimYPR, col="#808080")
text(1,max(rowMeans(hr1[,38+0.01, "Constrained", pos=4)
axis(1, at = seq(1, 6, by = 1))
mtext("(c)", side=3, line = -1.3, adj = 0.96, font=2, cex = 1)
plot(rowMeans(hr2[,pyrnoMP,]), type="b", ylim= xlimYPR,  xlab="Age", ylab = "Selectivity", panel.first=grid(col = "ivory3"), xaxt="n",las=1)
text(1,0.078, "Unconstrained", pos=4)
lines(rowMeans(hr2[,38,]), type="b", ylim=  xlimYPR, col="#808080")
text(1,max(rowMeans(hr2[,38,]))+0.01, "Constrained", pos=4)
axis(1, at = seq(1, 6, by = 1))
mtext("(d)",  side=3, line = -1.3, adj = 0.96, font=2, cex = 1)
plot(rowMeans(hr2[,pyrnoMP,]), type="b", ylim= xlimYPR,  xlab="Age", ylab = "Selectivity", panel.first=grid(col = "ivory3"), xaxt="n",las=1)
text(1,0.078, "Unconstrained", pos=4)
lines(rowMeans(hr2[,48,]), type="b", ylim=  xlimYPR, col="#808080")
text(1,max(rowMeans(hr2[,48,]))+0.01, "Constrained", pos=4)
axis(1, at = seq(1, 6, by = 1))
mtext("(d)",  side=3, line = -1.3, adj = 0.96, font=2, cex = 1)
hr2
rowMeans(hr2[,38,])
rowMeans(hr1[,38,])
rowMeans(hr2[,18,])
rowMeans(hr2[,18,])/rowMeans(hr2[,38,])
rowMeans(hr2[,38,])/rowMeans(hr2[,18,])
load("/home/nekane/Desktop/MSEresults/1quota12seasons_65000.RData")
load("~/Dropbox/PULSE/Pulseproject/data/gamsol_final.rdata")
predcod <- expand.grid(sizeclass=1:5,area=as.factor(c(1:16)),week=1:52)
predcod
predcod <- cbind(predcod, gear="BT", lhp=log(2000), year=1974, yrwk=1, fishhour = 65)
predcod$yearwk <- (predcod$year - 1970)*52 + predcod$week             # vormt extra kolom!
predcod$data<-rep(NA,nrow(predcod))
pred_with_se   <- predict(gamcod,newdata=predcod,se=T) #get predicted value
load("~/Dropbox/PULSE/Pulseproject/data/gamsol_final.rdata")
predsol <- expand.grid(sizeclass=1:5,area=as.factor(c(1:16)),week=1:52)
predsol <- cbind(predsol, gear="BT", lhp=log(2000), year=1974, yrwk=1, fishhour= 65)
predsol$yearwk <- (predsol$year - 1970)*52 + predsol$week
predsol$data   <-rep(NA,nrow(predsol))
pred_with_se   <- predict(gamsol,newdata=predsol,se=T)
View(predsol)
library("mgcv", lib.loc="~/R/x86_64-pc-linux-gnu-library/3.2")
pred_with_se   <- predict(gamsol,newdata=predsol,se=T)
pnorm(150,0.8)
pnorm(30,150,0.8)
pnorm(25,150,0.008)
qnbinom(0.90, 150,0.008)/24
qnbinom(0.90, 150,0.008)
qnbinom(0.90, 150,0.008)/24
pnorm(27.4, mean=50, sd=20)
pnorm(10.4, mean=50, sd=20)
pnorm(1, mean=50, sd=20)
pnorm(50, mean=50, sd=20)
pnorm(100, mean=50, sd=20)
qnbinom(0.90, 10, 1/3)
qnbinom(0.90, 10, 1/2)
pnorm(100, mean=50, sd=20)
qnbinom(0.90, 50, 20)/99
qnbinom(0.90, 50, 20)
pnorm(27.4, mean=50, sd=20)
qnbinom(0.90, 50, 20)/26
qnbinom(0.10, 50, 20)/26
qnbinom(0.10, 150, 20)
rnorm(30,mean=1,sd=1.5)
qnbinom(0.90, mu= 1500, size= 1.3 / (30 - 1)
Q
qnbinom(0.90, mu= 1500, size= 1.3) / (30 - 1)
qnbinom(0.90, mu= 1, size= 1.5) / (30 - 1)
0.71+0.52/2
(0.71+0.52)/2
load("/run/user/1000/gvfs/sftp:host=10.88.8.194/home/alzor001/modelresults/twoareas52weeks.RData")
dsvm_res <-  extract_dsvm_res (z, control, 1:5, 1:52)
extract_dsvm_res <- function(z, control, ages, season){
detach("package:FLCore", unload=TRUE)
simNumber <-control@simNumber
sp        <- c("sp1","sp2","sp3","sp4","sp5")
dsvm_res             <- as.data.frame(rbind(as.matrix(spp1Landings(sim(z))),
as.matrix(spp2Landings(sim(z))),
as.matrix(spp3Landings(sim(z))),
as.matrix(spp4Landings(sim(z))),
as.matrix(spp5Landings(sim(z)))))
names(dsvm_res)      <- "landings.wt"
dsvm_res$discards.wt <- c(rbind(as.matrix(spp1Discards(sim(z))),
as.matrix(spp2Discards(sim(z))),
as.matrix(spp3Discards(sim(z))),
as.matrix(spp4Discards(sim(z))),
as.matrix(spp5Discards(sim(z)))))
dsvm_res$catch.wt    <- dsvm_res$ landings + dsvm_res$discards
dsvm_res$effort      <- rep(rep(as.matrix(effort(sim(z))),each=length(ages)),length(sp))
dsvm_res$option      <- rep(rep(as.matrix(choice(sim(z))),each=length(ages)),length(sp))
dsvm_res$spp         <- as.factor(c(rep(sp, each=(simNumber*length(ages)*length(season)))))
dsvm_res$cat         <- ages
dsvm_res$season      <- c(rep(season, each=simNumber*length(ages)))
dsvm_res$vessel      <- rep(1:simNumber,each=length(ages))
dsvm_res$option[is.na(dsvm_res$option)] <- "Stay in port"
dsvm_res[c(1:4)]     <- lapply(dsvm_res[c(1:4)], function(x) as.numeric(as.character(x)))
dsvm_res[c(5:9)]     <- lapply(dsvm_res[c(5:9)], function(x) as.factor(x))
is.num               <- sapply(dsvm_res, is.numeric)
dsvm_res[is.num]     <- lapply(dsvm_res[is.num], round, 6)
# Just focus on sp1 and sp2
dsvm_res             <- subset(dsvm_res,(spp %in% c("sp1", "sp2")))
trip                 <- count(dsvm_res,c("spp","cat","season","option"))
names(trip)[5]       <- "trip"
dsvm_res             <- aggregate(cbind(landings.wt, discards.wt, catch.wt, effort)~ spp+cat+season+option, FUN=sum, data=dsvm_res)
dsvm_res             <- merge(dsvm_res, trip, by=c("spp","cat", "season","option"),all.x=TRUE)
return(dsvm_res)
}
dsvm_res <-  extract_dsvm_res (z, control, 1:5, 1:52)
extract_dsvm_res <- function(z, control, ages, season){
simNumber <-control@simNumber
sp        <- c("sp1","sp2","sp3","sp4","sp5")
dsvm_res             <- as.data.frame(rbind(as.matrix(spp1Landings(sim(z))),
as.matrix(spp2Landings(sim(z))),
as.matrix(spp3Landings(sim(z))),
as.matrix(spp4Landings(sim(z))),
as.matrix(spp5Landings(sim(z)))))
names(dsvm_res)      <- "landings.wt"
dsvm_res$discards.wt <- c(rbind(as.matrix(spp1Discards(sim(z))),
as.matrix(spp2Discards(sim(z))),
as.matrix(spp3Discards(sim(z))),
as.matrix(spp4Discards(sim(z))),
as.matrix(spp5Discards(sim(z)))))
dsvm_res$catch.wt    <- dsvm_res$ landings + dsvm_res$discards
dsvm_res$effort      <- rep(rep(as.matrix(effort(sim(z))),each=length(ages)),length(sp))
dsvm_res$option      <- rep(rep(as.matrix(choice(sim(z))),each=length(ages)),length(sp))
dsvm_res$spp         <- as.factor(c(rep(sp, each=(simNumber*length(ages)*length(season)))))
dsvm_res$cat         <- ages
dsvm_res$season      <- c(rep(season, each=simNumber*length(ages)))
dsvm_res$vessel      <- rep(1:simNumber,each=length(ages))
dsvm_res$option[is.na(dsvm_res$option)] <- "Stay in port"
dsvm_res[c(1:4)]     <- lapply(dsvm_res[c(1:4)], function(x) as.numeric(as.character(x)))
dsvm_res[c(5:9)]     <- lapply(dsvm_res[c(5:9)], function(x) as.factor(x))
is.num               <- sapply(dsvm_res, is.numeric)
dsvm_res[is.num]     <- lapply(dsvm_res[is.num], round, 6)
# Just focus on sp1 and sp2
dsvm_res             <- subset(dsvm_res,(spp %in% c("sp1", "sp2")))
trip                 <- count(dsvm_res,c("spp","cat","season","option"))
names(trip)[5]       <- "trip"
dsvm_res             <- aggregate(cbind(landings.wt, discards.wt, catch.wt, effort)~ spp+cat+season+option, FUN=sum, data=dsvm_res)
dsvm_res             <- merge(dsvm_res, trip, by=c("spp","cat", "season","option"),all.x=TRUE)
return(dsvm_res)
}
dsvm_res <-  extract_dsvm_res (z, control, 1:5, 1:52)
control     <- DynState.control(spp1LndQuota= 160000,  spp2LndQuota=1000000, spp1LndQuotaFine= 320, spp2LndQuotaFine= 3e6, fuelUse = 1, fuelPrice = 1600, landingCosts= 0.24,gearMaintenance= 87, addNoFishing= TRUE, increments= 20, spp1DiscardSteps= 0, spp2DiscardSteps= 0, sigma= 1, simNumber= 1000 , numThreads= 40, verbose=1)
dsvm_res <-  extract_dsvm_res (z, control, 1:5, 1:52)
dsvm_res <-  extract_dsvm_res (z, control, 1:5, 1:52)
library("plyr", lib.loc="~/R/x86_64-pc-linux-gnu-library/3.2")
dsvm_res <-  extract_dsvm_res (z, control, 1:5, 1:52)
modeffort<- subset(dsvm_res, spp %in% "sp1")
modeffort<- subset(dsvm_res, cat %in% "1")
View(modeffort)
modeffort<- with(modeffort,data.frame(spp, cat, season, option, effort, trip))
View(modeffort)
aggregate(cbind(effort,trip)~ spp+cat+option+season, FUN=sum, data=effort)
aggregate(cbind(effort,trip)~ spp+cat+option+season, FUN=sum, data=modeffort)
modeffort<- subset(dsvm_res, spp %in% "sp1")
modeffort<- subset(dsvm_res, cat %in% "1")
modeffort<- subset(dsvm_res, spp %in% "sp1")
modeffort<- subset(modeffort, cat %in% "1")
aggregate(cbind(effort,trip)~ spp+cat+option+season, FUN=sum, data=modeffort)
library(scales)
ggplot(all_effort, aes(x=as.factor(season), y=trip, fill=choice)) +
geom_bar(stat="identity", position = "fill", colour="black")+
scale_y_continuous( labels = percent)+
scale_fill_manual(values= c("gray100","gray60","gray20"))+
xlab("season") +
ylab("Fishing choice")
library("ggplot2", lib.loc="~/R/x86_64-pc-linux-gnu-library/3.2")
ggplot(all_effort, aes(x=as.factor(season), y=trip, fill=choice)) +
geom_bar(stat="identity", position = "fill", colour="black")+
scale_y_continuous( labels = percent)+
scale_fill_manual(values= c("gray100","gray60","gray20"))+
xlab("season") +
ylab("Fishing choice")
ggplot(modeffort, aes(x=as.factor(season), y=trip, fill=choice)) +
geom_bar(stat="identity", position = "fill", colour="black")+
scale_y_continuous( labels = percent)+
scale_fill_manual(values= c("gray100","gray60","gray20"))+
xlab("season") +
ylab("Fishing choice")
View(modeffort)
ggplot(modeffort, aes(x=as.factor(season), y=trip, fill=options)) +
geom_bar(stat="identity", position = "fill", colour="black")+
scale_y_continuous( labels = percent)+
scale_fill_manual(values= c("gray100","gray60","gray20"))+
xlab("season") +
ylab("Fishing choice")
ggplot(modeffort, aes(x=as.factor(season), y=trip, fill=option)) +
geom_bar(stat="identity", position = "fill", colour="black")+
scale_y_continuous( labels = percent)+
scale_fill_manual(values= c("gray100","gray60","gray20"))+
xlab("season") +
ylab("Fishing choice")
setwd("~/Dropbox/PULSE/Pulse")
options(width=240)
library(RDynState5NAsigmaseason52Age5)
library(ggplot2)
library(reshape2)
library(FLCore)
library(plyr)
library(scales)
source("/code/functions.R")
source("~/code/functions.R")
source("code/functions.R")
setwd("data/results")
temp <- list.files(pattern="*.csv")
for (i in 1:length(temp)) assign(temp[i], read.csv(temp[i]))
sp1<- sp2 <- sp3 <- sp4 <- sp5 <-    new("DynStateInput")
sp1 <- cpue_dsvm_sp(sol_beam_large.csv, sp1, 1.637352)  #SOLE
sp2 <- cpue_dsvm_sp(ple_beam_large.csv, sp2, 1.195788)  #PLAICE
sp3 <- cpue_dsvm_sp(cod_beam_large.csv, sp3, 0.8979249) #COD
catchMean(sp4) <- catchMean(sp5) <- array(0.01,dim=dim(catchMean(sp2)),dimnames=dimnames(catchMean(sp2)))
catchSigma(sp4)<- catchSigma(sp5)<- array(0.0000001,dim=dim(catchMean(sp2)),dimnames=dimnames(catchMean(sp2)))
price <- read.csv("data/input/Visprijzen.csv")
# SOLE = 5 cat 52 weeks3
sp1Price <- price[price$Spec == "Sole" & price$Category != 0 & price$Week != 0,]
sp1Price <- sp1Price[order(sp1Price$Week),]
sp1Price <- array(sp1Price$Price, dim=c(5,52), dimnames=dimnames(catchMean(sp1))[-3])
# Plaice 4 marketcat 1 discard with 0 marketvalue
sp2Price <- price[price$Spec == "Plaice" & price$Category != 0 & price$Week != 0,]
# create 5th cat with no marketvalue (discards)
sp2Price <- rbind(sp2Price,data.frame(Week = 1:52, Category = 5, Price = 0, Spec = "Plaice"))
sp2Price <- sp2Price[order(sp2Price$Week),]
sp2Price <- array(sp2Price$Price, dim=c(5,52), dimnames=dimnames(catchMean(sp2))[-3])
# Cod 5 marketcat with 52 weeks marketvalue
sp3Price <- price[price$Spec == "Cod" & price$Category != 0 & price$Category != 6 & price$Week != 0,]      #delete cat 0 and 6 and no week 0
sp3Price <- sp3Price[order(sp3Price$Week),]
sp3Price <- array(sp3Price$Price, dim=c(5,52), dimnames=dimnames(catchMean(sp3))[-3])
price <- read.csv("data/input/Visprijzen.csv")
setwd("~/Dropbox/PULSE/Pulse")
price <- read.csv("data/input/Visprijzen.csv")
# SOLE = 5 cat 52 weeks3
sp1Price <- price[price$Spec == "Sole" & price$Category != 0 & price$Week != 0,]
sp1Price <- sp1Price[order(sp1Price$Week),]
sp1Price <- array(sp1Price$Price, dim=c(5,52), dimnames=dimnames(catchMean(sp1))[-3])
# Plaice 4 marketcat 1 discard with 0 marketvalue
sp2Price <- price[price$Spec == "Plaice" & price$Category != 0 & price$Week != 0,]
# create 5th cat with no marketvalue (discards)
sp2Price <- rbind(sp2Price,data.frame(Week = 1:52, Category = 5, Price = 0, Spec = "Plaice"))
sp2Price <- sp2Price[order(sp2Price$Week),]
sp2Price <- array(sp2Price$Price, dim=c(5,52), dimnames=dimnames(catchMean(sp2))[-3])
# Cod 5 marketcat with 52 weeks marketvalue
sp3Price <- price[price$Spec == "Cod" & price$Category != 0 & price$Category != 6 & price$Week != 0,]      #delete cat 0 and 6 and no week 0
sp3Price <- sp3Price[order(sp3Price$Week),]
sp3Price <- array(sp3Price$Price, dim=c(5,52), dimnames=dimnames(catchMean(sp3))[-3])
sp4Price <- sp5Price <- array(c(0), dim=c(5,52), dimnames=dimnames(catchMean(sp1))[-3])
effort <- array(c(effort_dsvm_input(4.2,52,11,89.5,"south")[c(1:14,16),8]), dim=c(15,52), dimnames=list(option=dimnames(catchMean(sp1))[[3]],season=as.character(dimnames(catchMean(sp1))[[2]])))
array(c(effort_dsvm_input(4.2,52,11,89.5,"south")[c(1:14,16),8]), dim=c(15,52), dimnames=list(option=dimnames(catchMean(sp1))[[3]],season=as.character(dimnames(catchMean(sp1))[[2]])))
array(c(effort_dsvm_input(4.2,52,8.9,89.5,"south")[c(1:14,16),8]), dim=c(15,52), dimnames=list(option=dimnames(catchMean(sp1))[[3]],season=as.character(dimnames(catchMean(sp1))[[2]])))
